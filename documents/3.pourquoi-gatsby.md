# Pourquoi Gatsby fait l’affaire pour ce cas d’usage

## TL;DR

- Gatsby permet de **décorréler totalement la structure d’URL de la structure de fichiers**, ce qui est clé pour un site builder avancé où “n’importe quel contenu peut vivre à n’importe quelle URL” ([détail](#1-controle-fin-des-urls-et-du-contenu)).
- L’**écosystème Gatsby orienté contenu/SEO** (images, sitemaps, RSS, plugins matures) est très complet et stable depuis des années, alors que Next.js et Astro poussent des patterns plus orientés app/SSR, avec plus de variabilité et de coût opérationnel ([détail](#2-ecosysteme-oriente-seo-et-stabilite-en-production)).
- Pour un site à forte composante contenu, avec besoin d’**internationalisation, d’URLs traduites et de prévisibilité côté build/perf**, Gatsby reste une valeur sûre.

## 1. Contrôle fin des URLs et du contenu

Dans Gatsby, les pages sont créées **par code** (`createPage` dans `gatsby-node`) à partir des données (WordPress, autres APIs…), ce qui offre :

- Un **mapping totalement libre entre données et URLs** : n’importe quel type de contenu peut vivre sous n’importe quel chemin (`/`, `/banque/guide/xyz`, `/fr/pret-immobilier/abc`, etc.).
- La possibilité de **composer des templates et des composants réutilisables** sans être contraint par une hiérarchie de fichiers sur disque.

À l’inverse, des frameworks comme Next.js ou Astro s’appuient principalement sur le **file routing** :

- La structure des URLs reflète la structure des fichiers (`pages/blog/[slug].tsx`, `pages/testimonials/[slug].tsx`, etc.).
- On peut bien sûr mapper des slugs dynamiques, mais on reste dans un modèle où chaque “famille” de pages doit avoir son dossier ou sa route dédiée (`/blog`, `/testimonials`, etc.).

Pour un **site builder puissant** (type “page builder” marketing) :

- On veut pouvoir créer **une page de n’importe quel type, avec n’importe quels composants, à n’importe quelle URL**, sans devoir ajouter/dupliquer des fichiers de routes.
- On peut par exemple décider qu’une page “testimonial” vive sous `/banque/temoignage-client-x`, et une page “guide” sous `/banque/guide-y`, tout en utilisant le même template ou les mêmes blocs de contenu.

Sur la partie **internationalisation avec URLs traduites**, les frameworks file-based montrent vite leurs limites :

- Next.js gère l’i18n, mais reste centré sur des patterns de type `/[locale]/[slug]`, où la logique de routing est fortement liée à la structure des fichiers et des segments dynamiques.
- Dans un CMS avancé, on veut souvent que **le slug complet soit traduit** (y compris plusieurs segments de l’URL), et que cette structure dépende plus des données (WordPress, etc.) que des dossiers du projet.

Gatsby, en partant d’un **routage piloté par les données**, permet plus facilement :

- D’aligner les URLs sur la réalité métier et SEO (par marché, par langue, par typologie de contenu).
- De laisser **le CMS et les équipes contenu contrôler les slugs et les hiérarchies d’URL**, sans refactor de la structure de fichiers côté front.

## 2. Écosystème orienté SEO et stabilité en production

L’écosystème Gatsby a été pensé dès le départ pour des **sites de contenu et de marketing**, ce qui se traduit par :

- Des plugins SEO matures pour les **sitemaps, RSS, meta tags, images optimisées, structured data**, etc.
- Une chaîne d’optimisation d’images **au build ou déportée dans le cloud**, largement éprouvée et documentée.
- Une base très stable depuis plusieurs années : même si peu de nouvelles fonctionnalités arrivent, la stack actuelle est **robuste, prédictible et bien maîtrisée** par la communauté.

À l’inverse, Next.js et Astro adressent très bien des besoins d’**applications web** mais posent plusieurs problèmes dans ce contexte précis :

- Next.js souffre encore de **problèmes de performance en développement** (hot reload lent, consommation RAM élevée sur de gros projets), ce qui pèse sur la productivité quotidienne.
- En production, le **mode SSR** offre une flexibilité intéressante mais :
  - introduit un **coût de rendu serveur à chaque requête**,
  - expose davantage l’infra aux **pics de trafic et aux DDoS**,
  - et peut rapidement faire monter la facture d’hébergement si le trafic est fort.
- L’optimisation d’images dans Next.js est **liée à des services supplémentaires** (type Vercel Image Optimization) et n’est pas purement “au build” par défaut, ce qui ajoute une dépendance et un coût potentiels.

Pour Astro :

- Le framework introduit son propre langage et ses propres conventions de templates/composants (`.astro`), ce qui demande à l’équipe d’**apprendre un nouveau dialecte** en plus de React/TypeScript.
- Dans un contexte où l’on souhaite **rester dans un environnement contrôlé et standard (TypeScript, React)**, cette couche supplémentaire peut devenir un frein à l’adoption et à la maintenabilité.

Dans ce contexte précis (site très orienté contenu/SEO, gros volume de pages, besoin de stabilité et de prévisibilité) :

- Gatsby offre une **stack spécialisée pour le contenu**, avec un écosystème SEO complet et éprouvé.
- Il évite certains écueils opérationnels de Next.js (coût SSR, complexité infra) et la courbe d’apprentissage additionnelle d’Astro.
